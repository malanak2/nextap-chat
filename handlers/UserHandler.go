package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/gorilla/mux"
	"github.com/malanak2/nextap-chat/domain"
	"github.com/malanak2/nextap-chat/ports"
)

// HandleGetAllUsers godoc
//
// @Summary			 	Get all users
// @Description		 	Gets all users from the database - all their ids and usernames
// @Tags				user
// @Produce				json
// @Success				200 {object}	[]model.User
// @Failure				500 {object}	string
// @Router				/users [get]
func HandleGetAllUsers(w http.ResponseWriter, r *http.Request) {
	page := 1
	limit := 50
	var err error
	if r.URL.Query()["limit"] != nil {
		limit, err = strconv.Atoi(r.URL.Query()["limit"][0])
		if err != nil {
			http.Error(w, "Invalid limit format", http.StatusBadRequest)
			return
		}
	}

	if r.URL.Query()["page"] != nil {
		page, err = strconv.Atoi(r.URL.Query()["page"][0])
		if err != nil {
			http.Error(w, "Invalid page format", http.StatusBadRequest)
			return
		}
	}

	dest, err := ports.GetAllUsers(limit, page)
	if err != nil {
		http.Error(w, `Database query error `+err.Error(), http.StatusInternalServerError)
		return
	}
	marshal, err := json.Marshal(dest)
	if err != nil {
		http.Error(w, `Database marshal error `+err.Error(), http.StatusInternalServerError)
		return
	}
	fmt.Fprintf(w, "%s", marshal)
}

// HandleUserCreate godoc
//
// @Summary			 	Create user
// @Description		 	Creates a user with autogenerated id, username and a password
// @Tags				user, auth
// @Accept				json
// @Produce				json
// @Success				200 {object}	model.User
// @Failure				400 {object}	string
// @Failure				500 {object}	string
// @Router				/createUser [post]
func HandleUserCreate(w http.ResponseWriter, r *http.Request) {
	var body domain.CreateUser
	err := json.NewDecoder(r.Body).Decode(&body)

	if err != nil || body.Username == "" || body.Password == "" {
		http.Error(w, "Could not create user with these parameters", http.StatusBadRequest)
		return
	}
	if len(body.Username) < 3 {
		http.Error(w, "Username needs to have at least 3 characters.", http.StatusBadRequest)
	}
	user, err := ports.CreateUser(body.Username, body.Password)
	if err != nil {
		http.Error(w, "Could not create a user with these parameters", http.StatusBadRequest)
		return
	}
	marshal, err := json.Marshal(user)
	if err != nil {
		http.Error(w, `Database marshal error `+err.Error(), http.StatusInternalServerError)
		return
	}
	fmt.Fprintf(w, "%s", marshal)
}

// HandleUserLogin godoc
//
// @Summary			 	Login as user
// @Description		 	Logins as the specified user
// @Tags				user,auth
// @Accept				json
// @Produce				json
// @Success				200 {object}	string
// @Failure				400 {object}	string
// @Failure				500 {object}	string
// @Router				/login [post]
func HandleUserLogin(w http.ResponseWriter, r *http.Request) {
	var body domain.UserLogin
	err := json.NewDecoder(r.Body).Decode(&body)
	if err != nil {
		http.Error(w, "Failed to decode body", http.StatusBadRequest)
	}

	s, err := ports.UserLogin(body.Username, body.Password)
	if err != nil {
		http.Error(w, "Invalid credentials", http.StatusBadRequest)
	}
	marshal, err := json.Marshal(s)
	if err != nil {
		http.Error(w, `Failed to marshal login`, http.StatusInternalServerError)
	}
	fmt.Fprintf(w, "%s", string(marshal))
}

// HandleGetUserById godoc
//
// @Summary			 	Get user by id
// @Description	 	Gets a user by id and returns their id and username
// @Tags					user
// @Produce				json
// @Success				200 {object}	model.User
// @Failure				400 {object}	string
// @Failure				500 {object}	string
// @Router				/user/{id} [get]
func HandleGetUserById(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		http.Error(w, "User id not an integer", http.StatusBadRequest)
		return
	}

	dest, err := ports.GetUserById(int32(id))
	if err != nil {
		http.Error(w, "No user with this id", http.StatusBadRequest)
		return
	}

	marshal, err := json.Marshal(dest.User)
	if err != nil {
		http.Error(w, `Database marshal error `+err.Error(), http.StatusInternalServerError)
		return
	}
	fmt.Fprintf(w, "%s", marshal)
}

// HandleUserChangeName godoc
//
// @Summary			 	Change Username
// @Description		 	Changes username for the logged-in user
// @Tags				user
// @Accept				json
// @Produce				json
// @Success				200 {object}	model.User
// @Failure				400 {object}	string
// @Failure				500 {object}	string
// @Security			JWTTokenBasic
// @Router				/changeUsername [post]
func HandleUserChangeName(w http.ResponseWriter, r *http.Request) {
	var body domain.ChangeUsername
	err := json.NewDecoder(r.Body).Decode(&body)
	if err != nil {
		http.Error(w, "Failed to decode body", http.StatusBadRequest)
	}

	uid, ok := r.Context().Value("userId").(int)
	if !ok {
		// If this happens either the login function gives out a malformed but valid jwt, or somebody has our signing key - not good either way
		http.Error(w, "Invalid jwt. Please contact a site administrator", http.StatusInternalServerError)
		return
	}

	if len(body.Username) > 50 || len(body.Username) < 3 {
		http.Error(w, "Invalid username", http.StatusBadRequest)
		return
	}

	err = ports.ChangeUsername(int32(uid), body.Username)

	if err != nil {
		http.Error(w, `Database query error `+err.Error(), http.StatusInternalServerError)
		return
	}
	fmt.Fprintf(w, "OK")
}

func HandleDeleteUser(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		http.Error(w, "User id not an integer", http.StatusBadRequest)
	}
	err = ports.DeleteUser(int32(id))
	if err != nil {
		http.Error(w, `Database delete error `+err.Error(), http.StatusInternalServerError)
		return
	}
	fmt.Fprintf(w, "User with the id %d was deleted", id)
}

// HandleSearchUsers godoc
//
// @Summary			 	Search users
// @Description		 	Search from the database for a user with a string in name
// @Tags				user
// @Produce				json
// @Success				200 {object}	[]model.User
// @Failure				500 {object}	string
// @Router				/users/search/{txt} [get]

func HandleSearchUsers(w http.ResponseWriter, r *http.Request) {
	page := 1
	limit := 50
	var err error
	if r.URL.Query()["limit"] != nil {
		limit, err = strconv.Atoi(r.URL.Query()["limit"][0])
		if err != nil {
			http.Error(w, "Invalid limit format", http.StatusBadRequest)
			return
		}
	}

	if r.URL.Query()["page"] != nil {
		page, err = strconv.Atoi(r.URL.Query()["page"][0])
		if err != nil {
			http.Error(w, "Invalid page format", http.StatusBadRequest)
			return
		}
	}
	vars := mux.Vars(r)
	text, err := url.QueryUnescape(vars["txt"])
	if err != nil {
		http.Error(w, "Invalid text", http.StatusBadRequest)
		return
	}
	dest, err := ports.SearchUsers(text, limit, page)
	if err != nil {
		// Empty result
		if strings.Contains(err.Error(), "no rows in result set") {
			fmt.Fprintf(w, `[]`)
			return
		}
		http.Error(w, `Database query error `+err.Error(), http.StatusInternalServerError)
	}

	marshal, err := json.Marshal(dest)
	if err != nil {
		http.Error(w, `Database marshal error `+err.Error(), http.StatusInternalServerError)
	}
	fmt.Fprintf(w, "%s", marshal)
}
