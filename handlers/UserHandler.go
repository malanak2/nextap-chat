package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/go-jet/jet/v2/postgres"
	"github.com/golang-jwt/jwt/v5"
	"github.com/gorilla/mux"
	"github.com/malanak2/nextap-chat/domain"
	"github.com/malanak2/nextap-chat/gen/chatdb/public/model"
	. "github.com/malanak2/nextap-chat/gen/chatdb/public/table"
)

// HandleGetAllUsers godoc
//
// @Summary			 	Get all users
// @Description		 	Gets all users from the database - all their ids and usernames
// @Tags				user
// @Produce				json
// @Success				200 {object}	[]model.User
// @Failure				500 {object}	string
// @Router				/users [get]
func HandleGetAllUsers(w http.ResponseWriter, r *http.Request) {
	stmt := User.SELECT(User.ID, User.Username).FROM(User)
	var dest []struct {
		model.User
	}
	err := stmt.Query(domain.Db, &dest)
	if err != nil {
		http.Error(w, `Database query error `+err.Error(), http.StatusInternalServerError)
		return
	}
	marshal, err := json.Marshal(dest)
	if err != nil {
		http.Error(w, `Database marshal error `+err.Error(), http.StatusInternalServerError)
		return
	}
	fmt.Fprintf(w, "%s", marshal)
}

// HandleUserCreate godoc
//
// @Summary			 	Create user
// @Description		 	Creates a user with autogenerated id, username and a password
// @Tags				user
// @Accept				json
// @Produce				json
// @Success				200 {object}	model.User
// @Failure				400 {object}	string
// @Failure				500 {object}	string
// @Router				/createUser [post]
func HandleUserCreate(w http.ResponseWriter, r *http.Request) {
	var body domain.CreateUser
	err := json.NewDecoder(r.Body).Decode(&body)

	if err != nil || body.Username == "" || body.Password == "" {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}
	if len(body.Username) < 3 {
		http.Error(w, "Username needs to have at least 3 characters.", http.StatusBadRequest)
	}
	// TODO: validate password to match expectation
	stmt := User.INSERT(User.Username).VALUES(
		body.Username,
	).RETURNING(User.AllColumns)
	var dest struct {
		model.User
	}
	err = stmt.Query(domain.Db, &dest)
	if err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates unique constraint \"User_username_key\"") {
			http.Error(w, "A user with this username already exists.", http.StatusBadRequest)
			return
		}
		http.Error(w, `Database query error `+err.Error(), http.StatusInternalServerError)
		return
	}
	marshal, err := json.Marshal(dest.User)
	if err != nil {
		http.Error(w, `Database marshal error `+err.Error(), http.StatusInternalServerError)
		return
	}
	fmt.Fprintf(w, "%s", marshal)
}

// HandleUserLogin godoc
//
// @Summary			 	Login as user
// @Description		 	Logins as the specified user
// @Tags				user,auth
// @Accept				json
// @Produce				json
// @Success				200 {object}	string
// @Failure				400 {object}	string
// @Failure				500 {object}	string
// @Router				/login [post]
func HandleUserLogin(w http.ResponseWriter, r *http.Request) {
	var body domain.UserLogin
	err := json.NewDecoder(r.Body).Decode(&body)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
	}

	// TODO: verify password
	stmt := User.SELECT(User.AllColumns).FROM(User).WHERE(postgres.AND(User.Username.EQ(postgres.Text(body.Username))))
	var dest struct {
		model.User
	}
	err = stmt.Query(domain.Db, &dest)
	if err != nil {
		http.Error(w, "Invalid username or password.", http.StatusBadRequest)
		return
	}
	t := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		// Expires in about a month
		"exp":      jwt.NewNumericDate(time.Now().Add(time.Hour * 24 * 30)),
		"username": body.Username,
		"userId":   dest.ID,
	})
	s, _ := t.SignedString([]byte(os.Getenv("JWT_SECRET")))
	marshal, err := json.Marshal(s)
	if err != nil {
		http.Error(w, `Database marshal error `+err.Error(), http.StatusInternalServerError)
	}
	fmt.Fprintf(w, string(marshal))
}

// HandleGetUserById godoc
//
// @Summary			 	Get user by id
// @Description		 	Gets a user by id and returns their id and username
// @Tags				user
// @Produce				json
// @Success				200 {object}	model.User
// @Failure				400 {object}	string
// @Failure				500 {object}	string
// @Router				/user/{id} [get]
func HandleGetUserById(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		http.Error(w, "User id not an integer", http.StatusBadRequest)
		return
	}

	stmtAuthor := User.SELECT(User.AllColumns).WHERE(User.ID.EQ(postgres.Int(int64(id))))
	var dest struct {
		model.User
	}
	err = stmtAuthor.Query(domain.Db, &dest)
	if err != nil {
		http.Error(w, "No user with this id", http.StatusBadRequest)
		return
	}
	marshal, err := json.Marshal(dest.User)
	if err != nil {
		http.Error(w, `Database marshal error `+err.Error(), http.StatusInternalServerError)
		return
	}
	fmt.Fprintf(w, "%s", marshal)
}
