package handlers

import (
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/go-jet/jet/v2/postgres"
	"github.com/golang-jwt/jwt/v5"
	"github.com/gorilla/mux"
	"github.com/malanak2/nextap-chat/domain"
	"github.com/malanak2/nextap-chat/gen/chatdb/public/model"
	. "github.com/malanak2/nextap-chat/gen/chatdb/public/table"
)

// HandleGetAllUsers godoc
//
// @Summary			 	Get all users
// @Description		 	Gets all users from the database - all their ids and usernames
// @Tags				user
// @Produce				json
// @Success				200 {object}	[]model.User
// @Failure				500 {object}	string
// @Router				/users [get]
func HandleGetAllUsers(w http.ResponseWriter, r *http.Request) {
	page := 1
	limit := 50
	var err error
	if r.URL.Query()["limit"] != nil {
		limit, err = strconv.Atoi(r.URL.Query()["limit"][0])
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
	}

	if r.URL.Query()["page"] != nil {
		page, err = strconv.Atoi(r.URL.Query()["page"][0])
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
	}

	stmt := User.SELECT(User.ID, User.Username).FROM(User).LIMIT(int64(limit)).OFFSET(int64((page - 1) * limit))
	var dest []struct {
		model.User
	}
	err = stmt.Query(domain.Db, &dest)
	if err != nil {
		http.Error(w, `Database query error `+err.Error(), http.StatusInternalServerError)
		return
	}
	marshal, err := json.Marshal(dest)
	if err != nil {
		http.Error(w, `Database marshal error `+err.Error(), http.StatusInternalServerError)
		return
	}
	fmt.Fprintf(w, "%s", marshal)
}

// HandleUserCreate godoc
//
// @Summary			 	Create user
// @Description		 	Creates a user with autogenerated id, username and a password
// @Tags				user
// @Accept				json
// @Produce				json
// @Success				200 {object}	model.User
// @Failure				400 {object}	string
// @Failure				500 {object}	string
// @Router				/createUser [post]
func HandleUserCreate(w http.ResponseWriter, r *http.Request) {
	var body domain.CreateUser
	err := json.NewDecoder(r.Body).Decode(&body)

	if err != nil || body.Username == "" || body.Password == "" {
		http.Error(w, "Could not create user with these parameters", http.StatusBadRequest)
		return
	}
	if len(body.Username) < 3 {
		http.Error(w, "Username needs to have at least 3 characters.", http.StatusBadRequest)
	}
	// TODO: validate password to match expectation
	stmt := User.INSERT(User.Username).VALUES(
		body.Username,
	).RETURNING(User.AllColumns)
	var dest struct {
		model.User
	}
	err = stmt.Query(domain.Db, &dest)
	if err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates unique constraint \"User_username_key\"") {
			http.Error(w, "A user with this username already exists.", http.StatusBadRequest)
			return
		}
		http.Error(w, `Database query error `+err.Error(), http.StatusInternalServerError)
		return
	}
	marshal, err := json.Marshal(dest.User)
	if err != nil {
		http.Error(w, `Database marshal error `+err.Error(), http.StatusInternalServerError)
		return
	}
	fmt.Fprintf(w, "%s", marshal)
}

// HandleUserLogin godoc
//
// @Summary			 	Login as user
// @Description		 	Logins as the specified user
// @Tags				user,auth
// @Accept				json
// @Produce				json
// @Success				200 {object}	string
// @Failure				400 {object}	string
// @Failure				500 {object}	string
// @Router				/login [post]
func HandleUserLogin(w http.ResponseWriter, r *http.Request) {
	var body domain.UserLogin
	err := json.NewDecoder(r.Body).Decode(&body)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
	}

	// TODO: verify password
	stmt := User.SELECT(User.AllColumns).FROM(User).WHERE(postgres.AND(User.Username.EQ(postgres.Text(body.Username))))
	var dest struct {
		model.User
	}
	err = stmt.Query(domain.Db, &dest)
	if err != nil {
		http.Error(w, "Invalid username or password.", http.StatusBadRequest)
		return
	}
	t := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		// Expires in about a month
		"exp":      jwt.NewNumericDate(time.Now().Add(time.Hour * 24 * 30)),
		"username": body.Username,
		"userId":   dest.ID,
	})
	s, _ := t.SignedString([]byte(os.Getenv("JWT_SECRET")))
	marshal, err := json.Marshal(s)
	if err != nil {
		http.Error(w, `Database marshal error `+err.Error(), http.StatusInternalServerError)
	}
	fmt.Fprintf(w, string(marshal))
}

// HandleGetUserById godoc
//
// @Summary			 	Get user by id
// @Description		 	Gets a user by id and returns their id and username
// @Tags				user
// @Produce				json
// @Success				200 {object}	model.User
// @Failure				400 {object}	string
// @Failure				500 {object}	string
// @Router				/user/{id} [get]
func HandleGetUserById(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		http.Error(w, "User id not an integer", http.StatusBadRequest)
		return
	}

	stmtAuthor := User.SELECT(User.AllColumns).WHERE(User.ID.EQ(postgres.Int(int64(id))))
	var dest struct {
		model.User
	}
	err = stmtAuthor.Query(domain.Db, &dest)
	if err != nil {
		http.Error(w, "No user with this id", http.StatusBadRequest)
		return
	}
	marshal, err := json.Marshal(dest.User)
	if err != nil {
		http.Error(w, `Database marshal error `+err.Error(), http.StatusInternalServerError)
		return
	}
	fmt.Fprintf(w, "%s", marshal)
}

// HandleUserChangeName godoc
//
// @Summary			 	Change Username
// @Description		 	Changes username for the logged-in user
// @Tags				user
// @Accept				json
// @Produce				json
// @Success				200 {object}	model.User
// @Failure				400 {object}	string
// @Failure				500 {object}	string
// @Security			JWTTokenBasic
// @Router				/changeUsername [post]
func HandleUserChangeName(w http.ResponseWriter, r *http.Request) {
	var body domain.ChangeUsername
	err := json.NewDecoder(r.Body).Decode(&body)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
	}

	uid, ok := r.Context().Value("userId").(int)
	if !ok {
		// If this happens either the login function gives out a malformed but valid jwt, or somebody has our signing key - not good either way
		http.Error(w, "Invalid jwt. Please contact a site administrator", http.StatusInternalServerError)
		return
	}

	if len(body.Username) > 50 || len(body.Username) < 3 {
		http.Error(w, "Invalid username", http.StatusBadRequest)
		return
	}

	stmtCU := User.UPDATE(User.Username).WHERE(User.ID.EQ(postgres.Int(int64(uid)))).SET(postgres.String(body.Username)).RETURNING(User.AllColumns)
	var dest struct {
		model.User
	}
	err = stmtCU.Query(domain.Db, &dest)
	if err != nil {
		http.Error(w, `Database query error `+err.Error(), http.StatusInternalServerError)
		return
	}
	marshal, err := json.Marshal(dest.User)
	if err != nil {
		http.Error(w, `Database marshal error `+err.Error(), http.StatusInternalServerError)
	}
	fmt.Fprintf(w, "%s", marshal)
}

func HandleDeleteUser(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	id, err := strconv.Atoi(vars["id"])
	if err != nil {
		http.Error(w, "User id not an integer", http.StatusBadRequest)
	}
	// Get all messages for user
	stmtUserMessage := UserMessage.SELECT(UserMessage.AllColumns).WHERE(UserMessage.User.EQ(postgres.Int(int64(id))))
	var destUM []struct {
		model.UserMessage
	}
	err = stmtUserMessage.Query(domain.Db, &destUM)
	if err != nil {
		if !strings.Contains(err.Error(), "no rows in result set") {
			http.Error(w, `Database query error `+err.Error(), http.StatusInternalServerError)
		}
	}
	// For every message delete its entry in UserMessage and then delete the message
	for i := 0; i < len(destUM); i++ {
		stmtDelUM := UserMessage.DELETE().WHERE(UserMessage.ID.EQ(postgres.Int(int64(destUM[i].ID)))).RETURNING(UserMessage.AllColumns)
		var destDUM []struct {
			model.UserMessage
		}
		err = stmtDelUM.Query(domain.Db, &destDUM)
		if err != nil {
			http.Error(w, `Database query error `+err.Error(), http.StatusInternalServerError)
		}
		stmtDelMsg := Message.DELETE().WHERE(Message.ID.EQ(postgres.Int(int64(destUM[i].Message)))).RETURNING(Message.AllColumns)
		var destDMSG []struct {
			model.Message
		}
		err = stmtDelMsg.Query(domain.Db, &destDMSG)
		if err != nil {
			http.Error(w, `Database query error `+err.Error(), http.StatusInternalServerError)
		}
	}
	// Finally, delete user
	stmtDelUser := User.DELETE().WHERE(User.ID.EQ(postgres.Int(int64(id)))).RETURNING(User.AllColumns)
	var destDMSG []struct {
		model.User
	}
	err = stmtDelUser.Query(domain.Db, &destDMSG)
	if err != nil {
		http.Error(w, `Database query error `+err.Error(), http.StatusInternalServerError)
		return
	}
	fmt.Fprintf(w, "User with the id %d was deleted", id)
}

func HandleSearchUsers(w http.ResponseWriter, r *http.Request) {
	page := 1
	limit := 50
	var err error
	if r.URL.Query()["limit"] != nil {
		limit, err = strconv.Atoi(r.URL.Query()["limit"][0])
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
	}

	if r.URL.Query()["page"] != nil {
		page, err = strconv.Atoi(r.URL.Query()["page"][0])
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}
	}
	vars := mux.Vars(r)
	text, err := url.QueryUnescape(vars["txt"])
	if err != nil {
		http.Error(w, "Invalid text", http.StatusBadRequest)
		return
	}

	stmtSearch := User.SELECT(User.AllColumns).WHERE(postgres.LOWER(User.Username).LIKE(postgres.LOWER(postgres.String("%" + text + "%")))).LIMIT(int64(limit)).OFFSET(int64((page - 1) * limit))
	var dest []struct {
		model.User
	}
	fmt.Fprintf(os.Stdout, "Text: %s, Sql: %s", text, stmtSearch.DebugSql())
	err = stmtSearch.Query(domain.Db, &dest)
	if err != nil {
		if strings.Contains(err.Error(), "no rows in result set") {
			fmt.Fprintf(w, `[]`)
			return
		}
		http.Error(w, `Database query error `+err.Error(), http.StatusInternalServerError)
	}
	marshal, err := json.Marshal(dest)
	if err != nil {
		http.Error(w, `Database marshal error `+err.Error(), http.StatusInternalServerError)
	}
	fmt.Fprintf(w, "%s", marshal)
}
